/*
 *  source.h
 *  ISM
 *
 *  Created by Amanda Lind on 2/28/11.
 *  Copyright 2011 Pennsylvania State University. All rights reserved.
 *
 */


class source{
public:	
	// Overload the default constructor. 
	source() 
    {	source_number=0;
		position.x = 0.0; 
		position.y = 0.0;
		position.z = 0.0;
		order = 0;
		mother_source_ind=NULL;
        mother_wall_ind=NULL;
		strength=0.0;
		audible=true;
        legal=true;
    }
    
	
	// Constructor with parameters. 
	source(double long xpos, double long ypos, double long zpos, unsigned rdr, unsigned mthr_src_ind, unsigned mthr_wall_ind, long double strngth, bool adbl, bool lgl) 
	{	source_number=0;
		position.x = xpos; 
		position.y = ypos;
		position.z = zpos;
		order = rdr;
		mother_source_ind=mthr_src_ind;
        mother_wall_ind=mthr_wall_ind;
		strength=strngth;
		audible=adbl;
		legal=lgl;


    } 
    
	// Constructor with two parameters. 
	
	unsigned source_number;
	position_vector position;
	unsigned order;
	long double strength;
	bool audible;
	bool legal;
    unsigned mother_source_ind;
    unsigned  mother_wall_ind;
    
  void  assign(double long xpos, double long ypos, double long zpos, unsigned rdr, unsigned mthr_src_ind, unsigned mthr_wall_ind, long double strngth, bool adbl, bool lgl) 
	{	source_number=0;
		position.x = xpos; 
		position.y = ypos;
		position.z = zpos;
		order = rdr;
		mother_source_ind=mthr_src_ind;
        mother_wall_ind=mthr_wall_ind;
		strength=strngth;
		audible=adbl;
		legal=lgl;

    } 
    
    void print(std::vector<source> sources, std::vector<wall> planes, int num_orig_planes)
    {   std::cout<<"Source Number "<<source_number<<std::endl;
        std::cout<<"       Legal = "<<legal<<std::endl;
        std::cout<<"       Audible = "<<audible<<std::endl;
        std::cout<<"       Order = "<<order<<std::endl;
        std::cout<<"       Located at ("<<position.x<<", "<<position.y<<", "<<position.z<<")"<<std::endl;
        std::cout<<"       Is generated by reflection across wall(s) :";
     
        if(order==0)
        {    std::cout<<" N/A"<<std::endl;
        }
        if(order==1)
        {    std::cout<<mother_wall_ind<<std::endl;
        }
        if(order >1)
        {
            std::vector<int> ref_walls_inds(order); //allocate a vector, as long as the order, to store the reflection walls
            
            int temp_wall_ind,temp_src_ind;
            temp_wall_ind =mother_wall_ind;
            temp_src_ind =mother_source_ind;
            
            for(int i = order; i>0; i--)
            {
                ref_walls_inds[i-1]=temp_wall_ind;
                temp_wall_ind=sources[temp_src_ind].mother_wall_ind;
                temp_src_ind=sources[temp_src_ind].mother_source_ind;
            }
            for(int i = 0; i<ref_walls_inds.size(); i++)
            {  
                if(ref_walls_inds[i]>num_orig_planes-1)
                {std::cout<<ref_walls_inds[i]<<"("<< planes[ref_walls_inds[i]].num<<")" <<" ";  //EXC_BAD_ACCESS sometimes
                }
                else
                {    std::cout<<ref_walls_inds[i]<<" ";}
            }
            std::cout<<std::endl<<"       Expanding along the reflecting walls:"<<std::endl;

            for(int i = 0; i<ref_walls_inds.size(); i++)
            {  
                                std::cout<<"           Plane "<<ref_walls_inds[i]<<" is comprised of corners"<<std::endl;
                for(int cornind=0; cornind<planes[ref_walls_inds[i]].corners.size(); cornind++)
                {std::cout<<"                   "<<planes[ref_walls_inds[i]].corners[cornind].x<<" "<<planes[ref_walls_inds[i]].corners[cornind].y<<" "<<planes[ref_walls_inds[i]].corners[cornind].z<<std::endl;
                }
            }
        }
    }
    
};